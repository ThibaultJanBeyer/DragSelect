---
sidebar_position: 11
description: DragSelect is very customizable. You can even hook into the selection logic and change it to your likings
---

# Custom Selection Filter (Advanced Override)

> Disclaimer: By hooking into the selection youâ€™re modifying internal behavior. Donâ€™t expect support for any misbehaving caused by hooking in. We will try our best to not introduce breaking changes the overrideable methods but itâ€™s best if you double check each time before updating the library.

The logic for actually selecting elements is straight forward, it all happens [in the Selection module](https://github.com/ThibaultJanBeyer/DragSelect/blob/master/DragSelect/src/modules/Selection.js).

If you want to change the selectioning during the selection process (not before, not after) you can use the exposed method `filterSelected`. Weâ€™ll explain how here.
But why? Well, you might want to change the selection logic to your likings. 
Maybe you want to select only elements that have a certain class, or maybe you want to select only elements that are in a certain area. Or maybe you want to filter out the parent elements of the selected elements to prevent multiple elements laying on top of each other to be all selected/deselected together.
You can do that with the `filterSelected` method.
Weâ€™ll explain how here:

## Have a look at `.filterSelected()`

The method is called after the elements that are going to be selected/unselected were already collected. Just before the actual selection happens.
It gets called with the following arguments:

```ts 
Selection.filterSelected = ({ select, unselect, selectorRect }: {
  select:Map<DSElement,DSBoundingRect>, // the elements and their bounds that are supposed to be selected
  unselect:Map<DSElement,DSBoundingRect>, // the elements and their bounds that are supposed to be de-selected (or un-selected)
  selectorRect:DSBoundingRect // the bounds of the selector element
}) => ({ select, unselect }) // it expects you to return an object that holds the select and unselect keys of same type as the arguments
```

## Use the `.filterSelected()`

Now that we know how that looks like we can use it like so:

```ts
// initialize like you do before
const ds = new DragSelect({â€¦})

// then you can override the exposed internal method
ds.Selection.filterSelected = ({ selectorRect, select: _select, unselect: _unselect }: {
  select:Map<DSElement,DSBoundingRect>,
  unselect:Map<DSElement,DSBoundingRect>,
  selectorRect:DSBoundingRect
}) => {
  // here we just re-assign the maps to new variables so we can modify them without changing the original ones
  const select = new Map(_select), unselect = new Map(_unselect)
  // now we can do whatever, in this example we just filter out all elements that have a red color style if there is more than five selected elements in total
  select.forEach((boundingRect, element) => {
    if(element.style.color === 'red' && select.size > 5) {
      select.delete(element)
      unselect.set(element, boundingRect)
    }
  })
  // we return the modified maps
  return { select, unselect }
}
```

Thatâ€™s it, youâ€™ve successfully added a custom filter to the selection logic. Now go celebrate that youâ€™ve just learned something new! ðŸŽ‰
